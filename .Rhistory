# Initiate indices
first <- 1    # First element in group
# Loop over elements in column
for (row_index in 1:length(elements)) {
print(paste(col_index, row_index))
if (elements[row_index] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
break_matrix[row_index, col_index] <- 1
# Update start of next group
first <- row_index
}
}
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(break_matrix)){
for(row_index in 1:nrow(break_matrix)){
break_matrix[row_index, col_index] <- sum(break_matrix[row_index,1:col_index])
}
}
# Make first and last breaks always breaks
break_matrix[1,] <- 1
break_matrix[nrow(break_matrix),] <- 1
break_matrix[break_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(break_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
break_indices <- which(break_matrix[,col_index] == 1)
merge_matrix <- matrix(nrow = length(break_indices)-1,
ncol = 2)
for (break_i in 1:(length(break_indices)-1)){
merge_matrix[break_i,1] <- break_indices[break_i]
merge_matrix[break_i,2] <- break_indices[break_i+1] -1
}
merge_matrix <- merge_matrix[(merge_matrix[,2] - merge_matrix[,1]) > 0,]
merge_matrix <- as.vector(t(merge_matrix))
indicesi <- split(merge_matrix, ceiling(seq_along(merge_matrix)/2))
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
}
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df <- read.csv2("D:/Desktop/documento_teste.csv", header = FALSE)
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
df,
merge_cols = c("V1", "V2", "V3"))
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
wb <- openxlsx::loadWorkbook(excel_file)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if sheet name provided exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
break_matrix <- matrix(nrow = nrow(df)+1,
ncol = length(merge_cols))
break_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
# Loop over elements in column
for (row_index in 1:length(elements)) {
if (elements[row_index] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
break_matrix[row_index, col_index] <- 1
# Update start of next group
first <- row_index
}
}
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(break_matrix)){
for(row_index in 1:nrow(break_matrix)){
break_matrix[row_index, col_index] <- sum(break_matrix[row_index,1:col_index])
}
}
# Make first and last breaks always breaks
break_matrix[1,] <- 1
break_matrix[nrow(break_matrix),] <- 1
break_matrix[break_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(break_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
break_indices <- which(break_matrix[,col_index] == 1)
merge_matrix <- matrix(nrow = length(break_indices)-1,
ncol = 2)
for (break_i in 1:(length(break_indices)-1)){
merge_matrix[break_i,1] <- break_indices[break_i]
merge_matrix[break_i,2] <- break_indices[break_i+1] -1
}
merge_matrix <- merge_matrix[(merge_matrix[,2] - merge_matrix[,1]) > 0,]
merge_matrix <- as.vector(t(merge_matrix))
indicesi <- split(merge_matrix, ceiling(seq_along(merge_matrix)/2))
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
}
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
df,
merge_cols = c("V1", "V2", "V3"))
df <- read.csv2("D:/Desktop/documento_teste.csv", header = FALSE)
merge_cols <- c("V1", "V2", "V3")
# Matrix where break points are represented as 1's
break_matrix <- matrix(nrow = nrow(df)+1,
ncol = length(merge_cols))
break_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
# Loop over elements in column
for (row_index in 1:length(elements)) {
if (elements[row_index] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
break_matrix[row_index, col_index] <- 1
# Update start of next group
first <- row_index
}
}
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(break_matrix)){
for(row_index in 1:nrow(break_matrix)){
break_matrix[row_index, col_index] <- sum(break_matrix[row_index,1:col_index])
}
}
# Make first and last breaks always breaks
break_matrix[1,] <- 1
break_matrix[nrow(break_matrix),] <- 1
i = 1
col_index <- which(colnames(df) == merge_cols[i])
break_indices <- which(break_matrix[,col_index] == 1)
merge_matrix <- matrix(nrow = length(break_indices)-1,
ncol = 2)
for (break_i in 1:(length(break_indices)-1)){
merge_matrix[break_i,1] <- break_indices[break_i]
merge_matrix[break_i,2] <- break_indices[break_i+1] -1
}
merge_matrix <- merge_matrix[(merge_matrix[,2] - merge_matrix[,1]) > 0,]
merge_matrix <- as.vector(t(merge_matrix))
indicesi <- split(merge_matrix, ceiling(seq_along(merge_matrix)/2))
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
wb <- openxlsx::loadWorkbook(excel_file)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if sheet name provided exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
break_matrix <- matrix(nrow = nrow(df)+1,
ncol = length(merge_cols))
break_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
# Loop over elements in column
for (row_index in 1:length(elements)) {
if (elements[row_index] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
break_matrix[row_index, col_index] <- 1
# Update start of next group
first <- row_index
}
}
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(break_matrix)){
for(row_index in 1:nrow(break_matrix)){
break_matrix[row_index, col_index] <- sum(break_matrix[row_index,1:col_index])
}
}
# Make first and last breaks always breaks
break_matrix[1,] <- 1
break_matrix[nrow(break_matrix),] <- 1
break_matrix[break_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(break_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
break_indices <- which(break_matrix[,col_index] == 1)
merge_matrix <- matrix(nrow = length(break_indices)-1,
ncol = 2)
for (break_i in 1:(length(break_indices)-1)){
merge_matrix[break_i,1] <- break_indices[break_i]
merge_matrix[break_i,2] <- break_indices[break_i+1] -1
}
merge_matrix <- merge_matrix[(merge_matrix[,2] - merge_matrix[,1]) > 0,]
merge_matrix <- as.vector(t(merge_matrix))
indices <- split(merge_matrix, ceiling(seq_along(merge_matrix)/2))
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
}
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
df,
merge_cols = c("V1", "V2", "V3"))
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
wb <- openxlsx::loadWorkbook(excel_file)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if sheet name provided exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
break_matrix <- matrix(nrow = nrow(df)+1,
ncol = length(merge_cols))
break_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
# Loop over elements in column
for (row_index in 1:length(elements)) {
if (elements[row_index] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
break_matrix[row_index, col_index] <- 1
# Update start of next group
first <- row_index
}
}
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(break_matrix)){
for(row_index in 1:nrow(break_matrix)){
break_matrix[row_index, col_index] <- sum(break_matrix[row_index,1:col_index])
}
}
# Make first and last breaks always breaks
break_matrix[1,] <- 1
break_matrix[nrow(break_matrix),] <- 1
break_matrix[break_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(break_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
break_indices <- (which(break_matrix[,col_index] == 1))+1
merge_matrix <- matrix(nrow = length(break_indices)-1,
ncol = 2)
for (break_i in 1:(length(break_indices)-1)){
merge_matrix[break_i,1] <- break_indices[break_i]
merge_matrix[break_i,2] <- break_indices[break_i+1] -1
}
merge_matrix <- merge_matrix[(merge_matrix[,2] - merge_matrix[,1]) > 0,]
merge_matrix <- as.vector(t(merge_matrix))
indices <- split(merge_matrix, ceiling(seq_along(merge_matrix)/2))
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
}
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
df,
merge_cols = c("V1", "V2", "V3"))
library(devtools)
install_github("https://github.com/MarcioFCMartins/MMartins")
exists(a)
a <- 1
exists(a)
exists("a")
df <- a
paste(df)
missing(df)
missing(test)
?missing
is.null(teste)
?stopifnot
excel_file <- "D:/Desktop/documento_teste.xlsx"
file.exists(excel_file)
?stopifnot
is.character(sheet_name)
df
deparse(substitute(df))
excel_file
wb <- openxlsx::loadWorkbook(excel_file)
exists(deparse(substitute(wb)))
is.character(sheet_name)
sheet_name <- "teste"
is.character(sheet_name)
exists(deparse(substitute(df)))
merge_cols %in% names(df)
?stopifnot
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
wb <- openxlsx::loadWorkbook(excel_file)
# Check some basic conditions before running function
stopifnot(exists(deparse(substitute(wb))), # Was a workbook loaded?
is.character(sheet_name),# Was a sheet name provided
exists(deparse(substitute(df))), # Was an object provided to df?
merge_cols %in% colnames(df)) # Are merge columns present in df?
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if provided sheet name exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
break_matrix <- matrix(nrow = nrow(df)+1,
ncol = length(merge_cols))
break_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
# Loop over elements in column
for (row_index in 1:length(elements)) {
if (elements[row_index] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
break_matrix[row_index, col_index] <- 1
# Update start of next group
first <- row_index
}
}
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(break_matrix)){
for(row_index in 1:nrow(break_matrix)){
break_matrix[row_index, col_index] <- sum(break_matrix[row_index,1:col_index])
}
}
# Make first and last breaks always breaks
break_matrix[1,] <- 1
break_matrix[nrow(break_matrix),] <- 1
break_matrix[break_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(break_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
break_indices <- (which(break_matrix[,col_index] == 1))+1
merge_matrix <- matrix(nrow = length(break_indices)-1,
ncol = 2)
for (break_i in 1:(length(break_indices)-1)){
merge_matrix[break_i,1] <- break_indices[break_i]
merge_matrix[break_i,2] <- break_indices[break_i+1] -1
}
merge_matrix <- merge_matrix[(merge_matrix[,2] - merge_matrix[,1]) > 0,]
merge_matrix <- as.vector(t(merge_matrix))
indices <- split(merge_matrix, ceiling(seq_along(merge_matrix)/2))
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
}
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
library(devtools)
install_github(https://github.com/MarcioFCMartins/MMartins)
install_github("https://github.com/MarcioFCMartins/MMartins")
library(devtools)
library(roxygen2)
document()
install_github("https://github.com/MarcioFCMartins/MMartins")
library(MMartins)
?df_to_xlsx
df_to_xlsx(teste)
custom_theme()
?theme_custom()
