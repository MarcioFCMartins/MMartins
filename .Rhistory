elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
# Loop over elements in column
for (i in 1:length(elements)) {
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
}
# Remove rows identified as breaks twice (means they are groups of 1 element)
breaks <- breaks[!breaks %in% names(table(breaks)[table(breaks) > 1])]
index_matrix[breaks, col_index] <- 1
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(index_matrix)){
for(row_index in 1:nrow(index_matrix)){
index_matrix[row_index, col_index] <- sum(index_matrix[row_index,1:col_index])
}
}
index_matrix[index_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices <- which(index_matrix[,i] == 1)+1
indices <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
lapply(X = indices,
FUN = function(x) mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
} # End of column mergind section
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
documento_teste <- read.csv("D:/Desktop/documento_teste.csv", header=FALSE, sep=";", stringsAsFactors=FALSE)
View(documento_teste)
df_to_xlsx("D:/Desktop/documento_teste.xlsx", "teste", documento_teste, merge_cols = c("V1", "V2", "v3"))
View(documento_teste)
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
wb <- openxlsx::loadWorkbook(excel_file)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if sheet name provided exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
index_matrix <- matrix(nrow = nrow(df),
ncol = length(merge_cols))
index_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
# Loop over elements in column
for (i in 1:length(elements)) {
print(paste(col_index, i))
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
}
# Remove rows identified as breaks twice (means they are groups of 1 element)
breaks <- breaks[!breaks %in% names(table(breaks)[table(breaks) > 1])]
index_matrix[breaks, col_index] <- 1
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(index_matrix)){
for(row_index in 1:nrow(index_matrix)){
index_matrix[row_index, col_index] <- sum(index_matrix[row_index,1:col_index])
}
}
index_matrix[index_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices <- which(index_matrix[,i] == 1)+1
indices <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
lapply(X = indices,
FUN = function(x) mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
} # End of column mergind section
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df_to_xlsx("D:/Desktop/documento_teste.xlsx", "teste", documento_teste, merge_cols = c("V1", "V2", "v3"))
View(documento_teste)
i = 1
col_index = 3
elements[i] != elements[first]
i = 2
elements[i] != elements[first]
i = 1
breaks <- vector("numeric")
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
elements[i] != elements[first]
logical(0)
is.TRUE(logical(0))
logical(0) == TRUE
logical(0) == FALSE
i
elements[i]
df_to_xlsx("D:/Desktop/documento_teste.xlsx", "teste", documento_teste, merge_cols = c("V1", "V2", "V3"))
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
wb <- openxlsx::loadWorkbook(excel_file)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if sheet name provided exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
index_matrix <- matrix(nrow = nrow(df),
ncol = length(merge_cols))
index_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
# Loop over elements in column
for (i in 1:length(elements)) {
print(paste(col_index, i))
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
}
# Remove rows identified as breaks twice (means they are groups of 1 element)
breaks <- breaks[!breaks %in% names(table(breaks)[table(breaks) > 1])]
index_matrix[breaks, col_index] <- 1
}
# Propagate breaks from previous columns into next one
for (col_index in 2:ncol(index_matrix)){
for(row_index in 1:nrow(index_matrix)){
index_matrix[row_index, col_index] <- sum(index_matrix[row_index,1:col_index])
}
}
index_matrix[index_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices <- which(index_matrix[,i] == 1)+1
indices <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
} # End of column mergind section
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
documento_teste,
merge_cols = c("V1", "V2", "V3"))
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
documento_teste,
merge_cols = c("V1", "V2", "V3"))
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
documento_teste,
merge_cols = c("V1", "V2", "V3"))
df_to_xlsx <- function(excel_file, sheet_name, df, merge_cols = NULL){
# Set minimum column width for when auto column sizing is done
options("openxlsx.minWidth" = 6)
wb <- openxlsx::loadWorkbook(excel_file)
# Style for column header - bold, centered, wrapped, yellow background
# and thick border at the bottom
header_style <- openxlsx::createStyle(
textDecoration = "bold",
border         = c("top", "bottom"),
borderStyle    = c("thin", "thick"),
borderColour   = c("black", "black"),
fgFill         = c("#ffe699"),
wrapText       = TRUE,
halign         = "center")
# Check if sheet name provided exists - remove it if it does
if(sheet_name %in% names(wb)){
openxlsx::removeWorksheet(
wb,
sheet = sheet_name)
message("Your workbook already had a sheet named ", sheet_name,
".\nThis sheet has been replaced!")
}
# Create a new sheet in the workbook
openxlsx::addWorksheet(wb, sheetName = sheet_name)
# Write data.frame to created sheet - with header style
openxlsx::writeData(wb    = wb,
sheet = sheet_name,
x     = df,
headerStyle = header_style)
# Auto size columns to fit all the text
openxlsx::setColWidths(wb,
sheet = sheet_name,
cols  = 1:ncol(df),
widths = "auto")
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
index_matrix <- matrix(nrow = nrow(df),
ncol = length(merge_cols))
index_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
# Loop over elements in column
for (i in 1:length(elements)) {
print(paste(col_index, i))
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
}
# Remove rows identified as breaks twice (means they are groups of 1 element)
breaks <- breaks[!breaks %in% names(table(breaks)[table(breaks) > 1])]
index_matrix[breaks, col_index] <- 1
}
# # Propagate breaks from previous columns into next one
# for (col_index in 2:ncol(index_matrix)){
#   for(row_index in 1:nrow(index_matrix)){
#     index_matrix[row_index, col_index] <- sum(index_matrix[row_index,1:col_index])
#   }
# }
index_matrix[index_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices <- which(index_matrix[,i] == 1)+1
indices <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
lapply(X = indices,
FUN = function(x) openxlsx::mergeCells(wb = wb,
sheet = sheet_name,
cols = col_index,
rows = x))
}
} # End of column mergind section
#Save final excel workbook
openxlsx::saveWorkbook(wb, excel_file, overwrite = TRUE)
}
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
documento_teste,
merge_cols = c("V1", "V2", "V3"))
df_to_xlsx("D:/Desktop/documento_teste.xlsx",
"teste",
documento_teste,
merge_cols = c("V1", "V2", "V3"))
rm(list=ls())
merge_cols = c("V1", "V2", "V3")
documento_teste <- read.csv("D:/Desktop/documento_teste.csv", header=FALSE, sep=";")
View(documento_teste)
# Matrix where break points are represented as 1's
index_matrix <- matrix(nrow = nrow(df),
ncol = length(merge_cols))
index_matrix[] <- 0
df <- read.csv("D:/Desktop/documento_teste.csv", header=FALSE, sep=";")
# Matrix where break points are represented as 1's
index_matrix <- matrix(nrow = nrow(df),
ncol = length(merge_cols))
index_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
# Loop over elements in column
for (i in 1:length(elements)) {
print(paste(col_index, i))
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
}
# Remove rows identified as breaks twice (means they are groups of 1 element)
breaks <- breaks[!breaks %in% names(table(breaks)[table(breaks) > 1])]
index_matrix[breaks, col_index] <- 1
}
View(index_matrix)
View(index_matrix)
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices <- which(index_matrix[,i] == 1)+1
indices <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
# lapply(X = indices,
#        FUN = function(x) openxlsx::mergeCells(wb = wb,
#                                     sheet = sheet_name,
#                                     cols = col_index,
#                                     rows = x))
}
View(indices)
indiced
indices
# Merge cells of specified columns when they are equal
if(!is.null(merge_cols)) {
# Matrix where break points are represented as 1's
index_matrix <- matrix(nrow = nrow(df),
ncol = length(merge_cols))
index_matrix[] <- 0
# Loop over columns - create break points for each individual column
for (col_index in 1:length(merge_cols)) {
col_name <- merge_cols[col_index]
# Get vector of elements in column
elements  <- df[[col_name]]
# Initiate indices
first <- 1    # First element in group
breaks <- vector("numeric")
# Loop over elements in column
for (i in 1:length(elements)) {
print(paste(col_index, i))
if (elements[i] != elements[first]) {
# If 2 sequential elements are diferent, label them as break points
breaks <- c(breaks, first, i-1)
# Update start of next group
first <- i
}
}
# Remove rows identified as breaks twice (means they are groups of 1 element)
breaks <- breaks[!breaks %in% names(table(breaks)[table(breaks) > 1])]
index_matrix[breaks, col_index] <- 1
}
# # Propagate breaks from previous columns into next one
# for (col_index in 2:ncol(index_matrix)){
#   for(row_index in 1:nrow(index_matrix)){
#     index_matrix[row_index, col_index] <- sum(index_matrix[row_index,1:col_index])
#   }
# }
index_matrix[index_matrix > 0] <- 1
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices <- which(index_matrix[,i] == 1)+1
indices <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
# lapply(X = indices,
#        FUN = function(x) openxlsx::mergeCells(wb = wb,
#                                     sheet = sheet_name,
#                                     cols = col_index,
#                                     rows = x))
}
} # End of column merging section
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices[i] <- which(index_matrix[,i] == 1)+1
indices[i] <- split(indices, ceiling(seq_along(indices)/2))
# Apply merge function to row indices stored in list
# lapply(X = indices,
#        FUN = function(x) openxlsx::mergeCells(wb = wb,
#                                     sheet = sheet_name,
#                                     cols = col_index,
#                                     rows = x))
}
i = 1
col_index <- which(colnames(df) == merge_cols[i])
col_index
indices[[i]] <- which(index_matrix[,i] == 1)+1
rm(indices)
indices[[i]] <- which(index_matrix[,i] == 1)+1
indices <- list()
col_index <- which(colnames(df) == merge_cols[i])
indices[[i]] <- which(index_matrix[,i] == 1)+1
indices
indices[[i]] <- split(indices, ceiling(seq_along(indices)/2))
indices
indices <- list()
col_index <- which(colnames(df) == merge_cols[i])
indices_vector <- which(index_matrix[,i] == 1)+1
indices[[i]] <- split(indices, ceiling(seq_along(indices)/2))
View(indices)
indices
indices[[1]]
indices_vector <- which(index_matrix[,i] == 1)+1
indices[[i]] <- split(indices_vector, ceiling(seq_along(indices)/2))
indices
split(indices_vector, ceiling(seq_along(indices)/2))
indices_vector <- which(index_matrix[,i] == 1)+1
split(indices_vector, ceiling(seq_along(indices)/2))
?split
split(indices_vector, ceiling(seq_along(indices_vector)/2))
indices[[i]] <- split(indices_vector, ceiling(seq_along(indices_vector)/2))
indices
indices <- list()
# Convert matrix into a list and apply merge function
for (i in 1:ncol(index_matrix)){
col_index <- which(colnames(df) == merge_cols[i])
indices_vector <- which(index_matrix[,i] == 1)+1
indices[[i]] <- split(indices_vector, ceiling(seq_along(indices_vector)/2))
# Apply merge function to row indices stored in list
# lapply(X = indices,
#        FUN = function(x) openxlsx::mergeCells(wb = wb,
#                                     sheet = sheet_name,
#                                     cols = col_index,
#                                     rows = x))
}
indices
length(indices)
unlist(indices)
unlist(indices) %>% View()
library(dplyr)
unlist(indices) %>% View()
indices
?between
